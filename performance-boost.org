* Performance monitor on AMD


* Performance boost using OpenMP
** code for Matrix times Vector
#+BEGIN_SRC c++
  #include <omp.h>
  #include <iostream>
  #include <chrono>
  #include <vector>

  using namespace std;

  void *emalloc(size_t s) {
    void *result = malloc(s);
    if (result == NULL) {
      fprintf(stderr, "memory allocation failed");
      exit(EXIT_FAILURE);
    }
    return result;
  }


  int main(int argc, char* argv[]) {
    if (argc < 3) {
      cout << "Please specify m n on command line" << endl;
      exit(-1);
    }
    long m, n;
    
    m = stol(argv[1]);
    n = stol(argv[2]);
    int n_cpu = stoi(argv[3]);
    
    
    float* a = (float*)emalloc(n * sizeof(float));
    vector<float*> b;
    float* c = (float*)emalloc(n * sizeof(float));
    
    long i, j;
    
    auto started = std::chrono::high_resolution_clock::now();
    
    float* eachRow;
    
    
    for (i = 0; i < m; i++) {
      eachRow = (float*)emalloc(n * sizeof(float));
      for (j = 0; j < n; j++) {
        eachRow[j] = i;
      }
      b.push_back(eachRow);
    }
    
    
  #pragma omp parallel default(none) shared(c, n) private(i)
    {
  #pragma omp for
      for (i = 0; i < n; i++) {
        c[i] = 2.0;
      }
    }
    
  #pragma omp parallel default(none) shared(a,b,c,m,n) private(i, j) 
    {
      
  #pragma omp for
      for (i = 0; i < m; i++) {
        a[i] = 0.0;
        //    cout << "Thread " << omp_get_thread_num() << " is executing" << endl;
        for (j = 0; j < n; j++) {
          a[i] += (b[i][j] * c[j]);
        }
      }  
    }
    
    for (i = 0; i < m; i++) {
      free(b[i]);
    }
    
    
    free(c);
    free(a);
    
    auto done = std::chrono::high_resolution_clock::now();
    std::cout << "From initialization to finished, use: " << std::chrono::duration_cast<std::chrono::milliseconds>(done-started).count() << "ms" << endl;
    
    return 0;
  }
#+END_SRC
** executing result comparing between using OpenMP and without using OpenMP
- The time of executeing the program with OpenMP suppport is roughly half of the time of executing the program without OpenMP.
  Serial code execution records:
  #+BEGIN_SRC sh
    wzhao@r815:~/numa-knn$ ./bin/no_openmp_with_numa 10000 10000
    From initialization to finished, use: 2655ms
    wzhao@r815:~/numa-knn$ ./bin/no_openmp_with_numa 10000 10000
    From initialization to finished, use: 2384ms
    wzhao@r815:~/numa-knn$ ./bin/no_openmp_with_numa 10000 10000
    From initialization to finished, use: 2589ms
  #+END_SRC

  Simple parallel version execution time
  #+BEGIN_SRC sh
    wzhao@r815:~/numa-knn$ ./bin/openmp_with_numa 10000 10000
    From initialization to finished, use: 1436ms
    wzhao@r815:~/numa-knn$ ./bin/openmp_with_numa 10000 10000
    From initialization to finished, use: 1289ms
    wzhao@r815:~/numa-knn$ ./bin/openmp_with_numa 10000 10000
    From initialization to finished, use: 1278ms
  #+END_SRC

- use =/usr/bin/time= to examine the detail of execution on both version
  - for using OpenMP
    #+BEGIN_SRC sh
      wzhao@r815:~/numa-knn$ /usr/bin/time -v ./bin/openmp_with_numa 10000 10000
      From initialization to finished, use: 1246ms
      Command being timed: "./bin/openmp_with_numa 10000 10000"
      User time (seconds): 4.41
      System time (seconds): 0.76
      Percent of CPU this job got: 399%
      Elapsed (wall clock) time (h:mm:ss or m:ss): 0:01.29
      Average shared text size (kbytes): 0
      Average unshared data size (kbytes): 0
      Average stack size (kbytes): 0
      Average total size (kbytes): 0
      Maximum resident set size (kbytes): 1570640
      Average resident set size (kbytes): 0
      Major (requiring I/O) page faults: 0
      Minor (reclaiming a frame) page faults: 98332
      Voluntary context switches: 119
      Involuntary context switches: 623
      Swaps: 0
      File system inputs: 0
      File system outputs: 0
      Socket messages sent: 0
      Socket messages received: 0
      Signals delivered: 0
      Page size (bytes): 4096
      Exit status: 0

    #+END_SRC

  - for not using OpenMP
    #+BEGIN_SRC sh
      wzhao@r815:~/numa-knn$ /usr/bin/time -v ./bin/no_openmp_with_numa 10000 10000
      From initialization to finished, use: 2592ms
      Command being timed: "./bin/no_openmp_with_numa 10000 10000"
      User time (seconds): 2.38
      System time (seconds): 0.24
      Percent of CPU this job got: 99%
      Elapsed (wall clock) time (h:mm:ss or m:ss): 0:02.63
      Average shared text size (kbytes): 0
      Average unshared data size (kbytes): 0
      Average stack size (kbytes): 0
      Average total size (kbytes): 0
      Maximum resident set size (kbytes): 1568208
      Average resident set size (kbytes): 0
      Major (requiring I/O) page faults: 0
      Minor (reclaiming a frame) page faults: 98110
      Voluntary context switches: 2
      Involuntary context switches: 264
      Swaps: 0
      File system inputs: 0
      File system outputs: 0
      Socket messages sent: 0
      Socket messages received: 0
      Signals delivered: 0
      Page size (bytes): 4096
      Exit status: 0
    #+END_SRC

** The result is not very impressive, further investigation.
- When I use set number of threads to 32, it is better than setting it to 64 which is the Maximum number of cpu on the machine.

** Troubleshooting
- The following code could compile but during execution, it produces memory error messages
  #+BEGIN_SRC c
    #pragma omp parallel default(none) shared(m, n, b) private(eachRow, i, j)
      {
    #pragma omp for
        for (i = 0; i < m; i++) {
          eachRow = (float*)emalloc(n * sizeof(float));
          for (j = 0; j < n; j++) {
            eachRow[j] = i;
          }
          b.push_back(eachRow);
        }
      }  
  #+END_SRC
** How to use libnuma to boost?
- check numa architectures on Linux
  #+BEGIN_SRC sh
    wzhao@r815:~/numa-knn$ numactl --hardware
    available: 8 nodes (0-7)
    node 0 cpus: 0 4 8 12 16 20 24 28
    node 0 size: 65526 MB
    node 0 free: 62754 MB
    node 1 cpus: 32 36 40 44 48 52 56 60
    node 1 size: 65536 MB
    node 1 free: 60707 MB
    node 2 cpus: 2 6 10 14 18 22 26 30
    node 2 size: 65536 MB
    node 2 free: 63404 MB
    node 3 cpus: 34 38 42 46 50 54 58 62
    node 3 size: 65536 MB
    node 3 free: 63005 MB
    node 4 cpus: 3 7 11 15 19 23 27 31
    node 4 size: 65536 MB
    node 4 free: 62909 MB
    node 5 cpus: 35 39 43 47 51 55 59 63
    node 5 size: 65536 MB
    node 5 free: 63202 MB
    node 6 cpus: 1 5 9 13 17 21 25 29
    node 6 size: 65536 MB
    node 6 free: 11 MB
    node 7 cpus: 33 37 41 45 49 53 57 61
    node 7 size: 65520 MB
    node 7 free: 51391 MB
    node distances:
    node   0   1   2   3   4   5   6   7 
    0:  10  16  16  22  16  22  16  22 
    1:  16  10  22  16  16  22  22  16 
    2:  16  22  10  16  16  16  16  16 
    3:  22  16  16  10  16  16  22  22 
    4:  16  16  16  16  10  16  16  22 
    5:  22  22  16  16  16  10  22  16 
    6:  16  22  16  22  16  22  10  16 
    7:  22  16  16  22  22  16  16  10 
  #+END_SRC
  - There are seven processors, each has 7 cores
    
- 
