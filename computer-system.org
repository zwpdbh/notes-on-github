* Assembly
** Operation Suffixes
Assembly instructions are generally suffixed with the letters "b", "s", "w", "l", "q" or "t" to determine what size operand is being manipulated.
- b = byte (8 bit)
- s = short (16 bit integer) or single (32-bit floating point)
- w = word (16 bit)
- l = long (32 bit integer or 64-bit floating point)
- q = quad (64 bit)

** Address operand syntax
There are up to 4 parameters of an address operand that are presented in the syntax:
=segment:displacement(base register, index register, scale factor)=

It is equivalent to:
=segment:[base register + displacement + index register * scale factor]=

The base, index and displacement components can be used in any combination, and every component can be omitted.
#+BEGIN_SRC asm
          movl    -8(%ebp, %edx, 4), %eax  # Full example: load *(ebp + (edx * 4) - 8) into eax
          movl    -4(%ebp), %eax           # Typical example: load a stack variable into eax
          movl    (%ecx), %edx             # No index: copy the target of a pointer into a register
          leal    8(,%eax,4), %eax         # Arithmetic: multiply eax by 4 and add 8
          leal    (%edx,%eax,2), %eax      # Arithmetic: multiply eax by 2 and add edx
#+END_SRC 
* Processor Architecture
- start by defining a simple instruction set that use as a running example for processor implementations.
- provide some Background on digital hardware design.
- design a processor
  - present a functionally correct but somewhat impractical processor based on sequential operation.
  - with the sequential design as a basis, we then apply a series of transformations to create a pipelined processor.

** The Y86 Instruction Set Architecture
Defining an instruction set includes defining:
- the different state elements
- the set of instructions
- the encodings
- a set of programming conventions
- and the handling of exceptional events

*** Programmer-visible state
the “programmer” in this case is either someone writing programs in assembly code or a compiler generating machine-level code
- registers, have 8 including =%eax, %ecx, %edx, %ebx, %esi, %edi, %esp=, and =%ebp.=
  - =%esp= is used as a stack pointer by the push, pop, call and return instruction.
  - otherwise, the registers have no fixed meanings or values.
- condition codes, 3 single-bit, =ZF, SF, OF=, storing the information about the efect of the most recent arithmetic or logical instruction.
- PC, program counter holds the address of the instruction currently being executed.
- memory, is conceptually a large arry of bytes, holding both program and data.
- Stat, a status code.

*** Instructions and encoding
- As an example, let us generate the byte encoding of the instruction
  =rmmovl %esp,0x12345(%edx)= in hexadecimal
  
  According to the instruction set definition:
  | Byte             | 0 |   | 1     |  2 |  3 |  4 |  5 |
  |------------------+---+---+-------+----+----+----+----|
  | <>               | < | > | <>    | <> | <> | <> | <> |
  | rmmovl rA, D(rB) | 4 | 0 | rA rB |    |    |    |    |

  
*** Questions
- What's PC-relative addressing
