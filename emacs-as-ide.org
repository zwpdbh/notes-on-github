* Emacs as Java IDE
referenced from [[http://www.goldsborough.me/emacs,/java/2016/02/24/22-54-16-setting_up_emacs_for_java_development/][Setting up Emacs for Java Development]].
** Outline
1. Basic Environment: how to install and use /eclime/
2. Compiling: using Gradle to compile and run your code.
3. Autocomplete: configure sweek completion features with /company/.
4. Syntax-checking: Knowing what you're messing up at write-time.
5. Refactoring: Lightweight features that make life more pleasant.
** Basic Environment
*** About [[http://eclim.org][Eclim]]
*** Install
**** Eclipse
#+BEGIN_SRC sh
  brew install caskroom/cask/brew-cask 2> /dev/null

  # install 
  brew install caskroom/cask/eclipse-java
  brew install caskroom/cask/eclipse-ide

  # for uninstall
  brew cask zap eclipse-java
  brew cask zap eclipse-ide

#+END_SRC
Or, install eclipse using GUI installer.
#+RESULTS:
**** eclim
1) Download [[https://github.com/ervandew/eclim/releases/download/2.7.2/eclim_2.7.2.bin][eclim_xx.bin]]
2) execute the installer:
   #+BEGIN_SRC sh
     cd ~/Downloads
     chmod +x eclim_2.7.2.bin
     ./eclim_2.7.2.bin 

   #+END_SRC
Log:
-----------------------------------------
The eclim install completed successfully.
You can now start the eclimd server by executing the script:
  /Applications/Eclipse.app/Contents/Eclipse/eclimd

The most important thing  is know where you are putting the ~eclim~ and ~eclimd~ executables.

~eclim~ is what you could use from the command-line to interface with Eclipse. It sends all the commands to the server and handles the communication. The emacs mode introduced below wraps ~eclim~.

~eclimd~ is the eclim ~daemon~, which starts up and manages the server.

At, last: start that daemon:
#+BEGIN_SRC sh
  /Applications/Eclipse.app/Contents/Eclipse/eclimd
#+END_SRC
**** emacs-eclim
#+BEGIN_SRC emacs-lisp
  (use-package eclim
    :ensure t
    :config
    (add-hook 'java-mode-hook 'eclim-mode))

#+END_SRC

#+RESULTS:
: t
*** Running the server
Setup Eclipse server using eclimd
~M-x start-eclimd~
It asks to set the workplace's directory: such as ~\~/workspace~.

If get error, check the variable settings by:
~M-x customize-variable RET eclimd-executable~

*** Projects
Create project directory by:
~M-x eclim-project-create~

Open a project by:
~M-x eclim-project-open~

At this point you should be fully setup with emacs-eclim. Such as, use
~M-x eclim-java-refactor-rename-symbol-at-point~ to rename a symbol in your java code.

** Compiling
The /simplest/ way to compile and run Java code is with ~M-x compile~, where
you can type in your standard ~javac Foo.java Bar.java~ following by another ~M-x compile~ with ~java Fool~. 

But that is not intuitive. So use Gradle.

*** Setting up Gradle
- install Gradle
#+BEGIN_SRC sh
  brew install gradle
  brew upgrade gradle
#+END_SRC
- install gradle-mode from MELPA
#+BEGIN_SRC emacs-lisp
  (use-package gradle-mode
    :ensure t
    :config
    (progn
      (gradle-mode 1)
      (add-hook 'java-mode-hook '(lambda () (gradle-mode 1)))))
#+END_SRC
#+RESULTS:
: t
- set the ~build.gradle~ file in the root directory of your project
#+BEGIN_SRC gradle
  apply plugin: 'java'
  apply plugin: 'application'

  mainClassName = "Test"

  applicationDefaultJvmArgs = ["-ea"]
#+END_SRC
1) setting up the build file for Java by applying the java plugin
2) The application plugin we will use to run our code, as opposed to just building it or creating a jar (which is probably the easiest thing to do with Gradle). 
3) To run our code using the application plugin, we need to set a main class (we’ll define a Test.java file later).
4) Lastly I enabled assertions, just as an example.

*** Using Gradle
Two most important commands from gradle-mode are ~gradle-build~ and ~gradle-execute~.

The gradle expects a standard directory structure under project directory:
~src/main/java~ contains production code
~src/test/java~ contains test source code
~src/main/resources~ contains resources

*** Example
project folder is ~/Users/zw/workspace/emacs-java~:
#+BEGIN_SRC sh
  zwpdbhs-MBP:emacs-java zw$ tree .
  .
  ├── bin
  ├── build.gradle
  ├── build.gradle~
  └── src
      └── main
          └── java
              └── Test.java
#+END_SRC
Code in Test.java:
#+BEGIN_SRC java
  public class Test {
      public static void main(String... args) {
          for (int i = 0; i < 10; ++i) {
              System.out.println(i);
          }
      }
  }
#+END_SRC

~M-x gradle-build~ build the project when the current buffer is the opened .java

~gradle-execute~, will prompt to ask what tasks you want to execut, type:
~build run~, which build and run the program.

Make life easier by build ~M-x gradle-execute build run~ to a key-combination in our .emacs file:
#+BEGIN_SRC emacs-lisp
  (defun build-and-run ()
    (interactive)
    (gradle-run "build run"))

  (define-key gradle-mode-map (kbd "C-c C-r") 'build-and-run)
#+END_SRC


** Autocomplete
Choose autocomplete or company

** Syntax-checking
This feature actually requires no extra modes, but is entirely integrated into eclim. When you go over an error with your cursor, you can then use ~M-x eclim-problems-correct~ to select some possible corrections:
** Refactoring
1) Renaming symbols. When over a symbol, hit ~M-x eclim-java-refactor-rename-symbol-at-point~ (probably going to want to bind that to something).
2) Moving classes between files. Use ~M-x eclim-java-refactor-move-class~ for this.
